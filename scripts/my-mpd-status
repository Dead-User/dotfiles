#!/bin/zsh

pause=0.5
width=10
argv=($*)
for (( i=1; $i <= $#; i=$i + 1 )); do
  arg=${argv[$i]}
  case $arg in
    '--pause' | '-p' )
      : $((i = i + 1))
      if [ $i -gt $# ]; then
        echo 'no pause time specified' >&2
        exit 1
      fi
      pause=${argv[$i]};;
    '--len' | '-l' )
      i=$((i + 1))
      if [ $i -gt $# ]; then
        echo no length specified >&2
        exit 1
      fi
      width=${argv[$i]};;
    * )
      [[ $arg = '--help' || $arg = '-h' ]] && help=1 || help=0
      if [[ $help -eq 0 ]]; then
        echo "Error: unknown option $arg" >&2
      fi
      echo 'my-mpd-status, print mpd file name, fit in a fixed size, and auto rolling'
      echo 'usage:'
      echo '  -h --help:'
      echo '    print help text of this command'
      echo '  -p --pause-time TIME:'
      echo '    specify the pause time between rolling, in second'
      echo '  -l --len LEN:'
      echo '    specify the length to display'
      if [[ $help -eq 1 ]]; then
        exit 0
      else
        exit 1
      fi;;
  esac
done

function chr_width () {
  [[ $1 == [[:ascii:]] ]] && echo 1 || echo 2
}

index=0
len=1
hole=$width
buffer=''

while [ 1 ]; do
  name=$(mpc -f %file% \
    | sed -n '1p' \
    | awk -F. '{ for (i = 1; i < NF; ++i) print $i }' \
    | awk -F/ '{ print $2 }')
  if [[ $width -ge ${#name} ]]; then
    echo $name
    sleep $pause
  else
    buffer="$name      $name"
    while [[ 1 ]]; do
      # get the width of the next character (not yet in the output)
      c=${buffer:$((index + len)):1}
      # w=$(chr_width ${buffer:$((index + len + 1)):1})
      w=$(chr_width $c)
      if [[ $hole -lt $w ]]; then
        # the next character is too large, don't display it
        break
      else
        # the next character can fit in the hole,
        # fill it in the hole and continue
        : $((len = len + 1))
        : $((hole = hole - w))
      fi
    done
    # echo "$index:$hole:$c:$w:$len" >&2
    if [[ $hole -eq 0 ]]; then
      echo "${buffer:$index:$len}"
    else
      echo "${buffer:$index:$len} "
    fi
    # pop the first character, update the size of hole
    : $(( hole = hole + $(chr_width ${buffer:$index:1}) ))
    : $(( index = index + 1, len = len - 1 ))
    if [[ $index -ge $((${#name} + 6)) ]]; then
      index=0
    fi
    sleep $pause
  fi
done
# set count 1
# set len $argv[1]
# while true;
#   set fname (string split -m 1 '\n' (mpc -f %file%))[1]
#   set name (string split -m 1 '/' (string split -m 1 -r '.' $fname)[1])[2]
#   if test $len -ge (string length $name)
#     echo $name
#   else
#     echo (string sub -s $count -l $len (string join '' -- $name (string repeat -n 6 ' ') $name))
#   end
#   if test $count -ge (math (string length $name) + 6)
#    set count 0
#   end
#   set count (math $count + 1)
#   sleep 0.5;
# end
